% vim: nu expandtab shiftwidth=2 softtabstop=2 foldmethod=marker

\definecolor{LightCyan}{rgb}{0,1,1}
\definecolor{DarkCyan}{rgb}{0,0.88,0.88}
\lstset{language=C++,
	frame=tb,
	tabsize=2,
	showstringspaces=false,
	commentstyle=\color{green},
	keywordstyle=\color{blue},
	stringstyle =\color{red}}

\section{Deterministic Algorithm Analysis}
This section is also covered in Chapter 5 of the book.
\begin{enumerate}
\item Outline
  \begin{itemize}
  \item Introduction
  \item Loop Counting
  \item Euclidean Algorithm for GCD
  \item Divide and Conquer
    \begin{itemize}
    \item Binary Search
    \end{itemize}
  \item Sorting Algorithms
    \begin{itemize}
    \item Merge Sort, Quicksort
    \item Lower Bound for the comparison based algorithms
    \end{itemize}
  \item Traversing Binary Trees
  \end{itemize}
\subsection{Introduction}
\item Elements of Algorithm Analysis
  \begin{itemize}
  \item Analyzing an algorithm is to determine the amount of resources needed to run it
  \item Characterize the amount of resources as a function $$f:N\rightarrow[0,\infty)$$
    \begin{itemize}
    \item Value of $f(n)$ depends on types of complexity considered
    \end{itemize}
  \item Types of algorithm complexity are classified by
    \begin{itemize}
    \item Types of resources: time, space
    \item Scenarios: worst case, average case, best case
    \end{itemize}
  \end{itemize}
\item Types of Algorithm Complexity \\
\begin{tabular}{p{2cm} p{5cm} p{5cm}}
\rowcolor{LightCyan} & Time & Space \\
\rowcolor{DarkCyan} Worst case & $f(n)=$ maximum number of basic operations the algorithm uses on a problem of size n. & $f(n)=$ maximum amount of memory the algorithm uses on a problem of size n. \\
\rowcolor{LightCyan}  Average case & $f(n)=$ average number of basic operations the algorithm uses on a problem of size n. & $f(n)=$ average amount of memory the algorithm uses on a problem of size n. \\
\rowcolor{DarkCyan}  Best case & $f(n)=$ minimum number of basic operations the algorithm uses on a problem of size n. & $f(n)=$ minimum amount of memory the algorithm uses on a problem of size n. \\
\end{tabular}
  \begin{itemize}
  \item Basic Operations: operations that require a limited number of assembly code instructions aafter compilation
  \end{itemize}
\item Problem Size
  \begin{itemize}
  \item The size of an input to a problem is determined by the number of bits required to represent it
  \item Problem size is determined by the size of its input
    \begin{itemize}
    \item Must be unlimited
    \end{itemize}
  \begin{tabular}{l l}
  \rowcolor{LightCyan} Common Input Types & Problem Size \\
  \rowcolor{DarkCyan} An integer N & $\log{(N)}$ \\
  \rowcolor{LightCyan} An array of length N & N \\
  \rowcolor{DarkCyan} A graph of N nodes & $N^{2}$
  \end{tabular}
  \end{itemize}
\item Principles for Analyzing Time Complexity
  \begin{itemize}
  \item Each basic operation executes in constant time $\rightarrow$ time complexity O(1)
  \item A sequence of a fixed number of basic operations executes in constant time
  \item Time complexity of a sequence of code blocks is of the following form
  \begin{tabular}{l}
  \rowcolor{LightCyan} Basic Operations \\
  \rowcolor{DarkCyan} Loop \\
  \rowcolor{LightCyan}Basic Operations
  \end{tabular}
  \item[] is determined by time complexity of the loop block.
  \end{itemize}
\item Principles of Analyzing Space Complexity
  \begin{itemize}
  \item Only calculate \emph{extra} memory required
    \begin{itemize}
    \item For a function call, it's stack frame, which contains:
      \begin{itemize}
      \item local variables, parameter values,
      \item return addresses, and space for returned value
      \end{itemize}
    \end{itemize}
  \item Example 1:
\begin{lstlisting}
double max(double a[], int n) //array is passed as pointer
{
  double currentMax=a[0];    //variable of constant size
  for (int i=0; i<n; i++)
    if (a[i] > currentMax)
      currentMax=a[i];
  return currentMax;
}
\end{lstlisting}
  \end{itemize}
\subsection{Loop Analysis}
\item Time Complexity of Loops
  \begin{itemize}
  \item Time complexity function of a loop is determined by
    \begin{itemize}
    \item The total number of iterations
    \item The number of basic operations in each iteration
    \end{itemize}
  \item Example 1:
\begin{lstlisting}[mathescape=true]
double max(double a[], int n) //array is passed as pointer
{
double currentMax=a[0];    //basic operation
for (int i=0; i<n; i++)  //(n-1) iterations in any case
  if (a[i] > currentMax) //basic operation
    currentMax=a[i];
return currentMax; // basic operation
} //total time complexity $\color{green}\Theta(n)$
\end{lstlisting}
  \end{itemize}
\item Time Complexity of Loops: \\
      Worst Case v.s. Best Case
  \begin{itemize}
  \item Example 2: linear search 
\begin{lstlisting}
int linearSearch(const double a[], int n, double key)
{
  for(int i=0; i<n; i++)
    if(a[i]==key)
      return i; //key is found at index i
  return -1; //not found
}
\end{lstlisting}
    \begin{itemize} 
    \item \textbf{Worst Case}: happens when key is in the last position or not in the array $\rightarrow f(n)=\Theta(n)$
    \item \textbf{Best Case}: happens when key is at index 0 $\rightarrow f(n)=\Theta(1)$
    \end{itemize}
  \end{itemize}
\item Counting Iterations of Nested Loops
  \begin{itemize}
  \item \textbf{Easy Case:}
    \begin{itemize}
    \item if the number of iterations for the inner loop does not depend on the control variable for the outer loop
    \end{itemize}
  \item \textbf{Example 3:}
\begin{lstlisting}
for (i=1; i*i<=n; i++)
  for (j=0; j<n; j++)
    //inner loop body
\end{lstlisting}
    \begin{itemize}
    \item Outer loop: $\left\lfloor\sqrt{n}\right\rfloor$
    \item Inner loop: n iterations in any iteration of the outer loop
    \item Total number of iterations $\left\lfloor\sqrt{n}\right\rfloor n=\Theta\left(n^{\frac{3}{2}}\right)$
    \end{itemize}
  \end{itemize}
\item Counting Iterations of Nested Loops
  \begin{itemize}
  \item \textbf{Harder case:}
    \begin{itemize}
    \item if the number of iterations for the inner loop depends on the control variable for the outer loop
    \end{itemize}
  \item \textbf{Example 4:}
\begin{lstlisting}
for (i=1; i*i<=n; i++)
  for (j=0; j<i; j++)
    //inner loop body
\end{lstlisting}
    \begin{itemize}
    \item Outer loop: $\left\lfloor\sqrt{n}\right\rfloor$
    \item Inner loop: i iterations in the $i^{th}$ iteration of the outer loop
    \item Total number of iterations: $ \displaystyle \sum\limits_{i=1}^{\left\lfloor\sqrt{n}\right\rfloor}i=\frac{\left\lfloor\sqrt{n}\right\rfloor\left(\left\lfloor\sqrt{n}\right\rfloor+1\right)}{2}=\Theta (n)$
    \end{itemize}
  \end{itemize}
\item Counting Iterations of Nested Loops
  \begin{itemize}
  \item \textbf{Example 4:}
\begin{lstlisting}
for (i=1; i<=n; k=k/2)
  for (j=0; j<k; j++)
    //inner loop body
\end{lstlisting}
    \begin{itemize}
    \item Outer loop: n iterations.
    \item Inner loop: k iterations in the $i^{th}$ iteration of the outer loop, where $k=\left\lfloor\frac{n}{2^{i}}\right\rfloor$, for $i=0$,...,n-1.
    \item Total Number of iterations: $\displaystyle \sum\limits_{i=0}^{n-1}\left\lfloor\frac{n}{2^{i}}\right\rfloor =\Theta (n)$
    $$n-1 < \left\lfloor n\right\rfloor \leq \sum\limits_{i=0}^{n-1}\left\lfloor\frac{n}{2^{i}}\right\rfloor \leq \sum\limits_{i=0}^{n-1}\frac{n}{2^{i}} = n\left(\frac{1-\left(\frac{1}{2}\right)^{n}}{1-\frac{1}{2}}\right) < 2n$$
    \end{itemize}
  \end{itemize}
\item More Examples/Practice
  \begin{itemize}
  \item Determine the worst case time complexity of the following function:
\begin{lstlisting}
void linearInsertionSort(double a[], int n)
{
  int i, k;
  for (k=1; k<n; ++k)
  {
    double temp =a[k];
    for (i=k-1; i>=0 && a[i]>temp; --i)
      a[i+1]=a[i];
    a[i+1]=temp;
  }
}
\end{lstlisting}
  \end{itemize}
\subsection{Euclidean Algorithm for GCD}
\item Computing Greatest Common Divisors (GCD)
  \begin{itemize}
  \item The \textcolor{DarkCyan}{greatest common divisor} of two integers a and b
    \begin{itemize}
    \item denoted \textcolor{DarkCyan}{gcd(a,b)}
    \item is the largest positive integer that divides both a and b
    \end{itemize}
  \item Euclid's algorithm for computing GCD
    \begin{itemize}
    \item One of the oldest algorithms in common use $(>2000$ years)
    \item An important routine in the RSA encryption
    \item Based on \textbf{Theorem:} Let m and n be positive integers, with $m\leq n$. Then $gcd(m,n)=gcd(n mod m,m)$
      \begin{itemize}
      \item Example: $gcd(260,412)=gcd(152,260)$ because $412\%260=152$
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item Euclid's GCD algorithm \\
\lstset{language=C++,
	frame=tbl,
	tabsize=2,
	showstringspaces=false,
	commentstyle=\color{green},
	keywordstyle=\color{blue},
	stringstyle =\color{red}}
\noindent\begin{minipage}[t]{0.5\textwidth} %left side
\textbf{Recursive Version}
\begin{lstlisting}
int gcd(int m, int n)
//assume 0<=m<=n
{
  if (m==0)
    return n;
  else
    return gcd(n%m, m);
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth} %right side
\textbf{Iterative Version}
\begin{lstlisting}
int gcd(int m, int n)
//assume 0<=m<=n
{
  int dividend=n;
  int divisor=m;
  while (divisor !=0)
  {
    int remainder=dividend%divisor;
    dividend=divisor;
    divisor=remainder;
  }
  return dividend;
}
\end{lstlisting}
\end{minipage}
\item Analyzing Euclid's Algorithm
  \begin{itemize}
  \item Consider he iterative version
  \item Will focus on worst case time complexity
  \item The number of iterations of the \textcolor{DarkCyan}{while} loop
    \begin{itemize}
    \item Equals the number of divisions executed in the lop
    \item Example: input $n=412$, $m=260\rightarrow6$ divisions $\rightarrow6$ iterations
    \end{itemize}
  \end{itemize}
  \begin{tabular}{l r r r r r r r}
  \rowcolor{LightCyan} \textbf{Division\#} & 1   & 2   & 3   & 4   & 5  & 6  & End of loop \\
  \rowcolor{DarkCyan} dividend            & 412 & 260 & 152 & 108 & 44 & 20 & 4 \\
  \rowcolor{LightCyan} divisor            & 260 & 152 & 108 & 44  & 20 & 4  & 0 \\
  \rowcolor{DarkCyan} remainder           & 152 & 108 & 44  & 20  & 4  & 0  &   \\
  \end{tabular}
\item Formal Analysis of Euclid's Algorithm
  \begin{itemize}
  \item Consider the Euclid algorithm on inputs \emph{m} and \emph{n}
    \begin{itemize}
    \item Assume $0\leq m\leq n$
    \item Let $k$ denote the total number of divisions or iterations
    \item Let $d_{i}$ be the divisor of the $i^{th}$ division from the last one.
    \item For all $i=1$,...,$k-1$, $d_{i}=d_{i+2}$ mod $d_{i+1}$
    \item [$\Rightarrow$] $d_{i} < d_{i+1}$ and $d_{i+1}=\left\lfloor\frac{d_{i+2}}{d_{i+1}}\right\rfloor d_{i+1}+d_{i}$
    \end{itemize}
  \end{itemize}
  \begin{tabular}{l c c c c c c}
  \rowcolor{LightCyan} \textbf{Division\#} & 1   & 2   & ...   & k-2   & k-1  & k (Last) \\
  \rowcolor{DarkCyan} dividend            & $d_{k+1}=n$ & $d_{k}$ & ... & $d_{4}$ & $d_{3}$ & $d_{2}$ \\
  \rowcolor{LightCyan} divisor            & $d_{k}=m$ & $d_{k-1}$ & ... & $d_{3}$  & $d_{2}$ & $d_{1}$ \\
  \rowcolor{DarkCyan} remainder           & $d_{k-1}$ & $d_{k-2}$ & ...  & $d_{2}$  & $d_{1}$  & 0 \\
  \end{tabular}
\item Formal Analysis of Euclid's Algorithm
  \begin{itemize}
  \item Now find a \emph{good} lower bound on $d_{i}$'s
    \begin{itemize}
    \item $d_{1}\geq 1$   since a valid divisor must be nonzero
    \item $d_{2}\geq 2$   since $d_{2}>d_{1}$ \& $d_{i}$'s are integers
    \item $d_{i+2}\geq d_{i+1} +d_{i}$ since $d_{i+2}=\left\lfloor\frac{d_{i+2}}{d_{i+1}}\right\rfloor d_{i+1}+d_{i}$ and $\frac{d_{i+2}}{d_{i+1}}\geq 1$
    \end{itemize}
  \end{itemize}
  \begin{tabular}{l c c c c c c c}
  \rowcolor{LightCyan} \textbf{Division\#} & ... & $k-5$ & $k-4$ & $k-3$ & $k-2$  & $k-1$ & k (Last) \\
  \rowcolor{DarkCyan} dividend & & $d_{7}$ & $d_{6}$ & $d_{5}$ & $d_{4}$ & $d_{3}$ & $d_{2}$ \\
  \rowcolor{LightCyan} divisor & & $d_{6}$ & $d_{5}$ & $d_{4}$ & $d_{3}$ & $d_{2}$ & $d_{1}$ \\
  \rowcolor{DarkCyan} divisor $>=$ & & 13 & 8 & 5 & 3 & 2 & 1 \\
  \rowcolor{LightCyan} remainder & & $d_{5}$ & $d_{4}$ & $d_{3}$ & $d_{2}$ & $d_{1}$ & 0 \\
  \end{tabular}
\item Formal Analysis of Euclid's Algorithm
  \begin{itemize}
  \item Can prove by induction: $d_{i}\geq F_{i+1}$ for all $i\geq 1$
    \begin{itemize}
    \item Where $F_{i}$ is the $i^{th}$ Fibonacci number
    \end{itemize}
  \item Since $d_{k}=m$, we have 
  \item [] $m\geq F_{k+1}=\frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^{k+1} -\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^{k+1}$ 
  \item [] $\Rightarrow m\geq\frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^{k+1}-1$ 
  \item [] $\Rightarrow k=O(\log{(m)})$
  \item Worst case time complexity: O(log(min\{m,n\}))
  \end{itemize}
\item {\color{green}More Examples/Practice}
  \begin{itemize}
  \item What is the worst case time complexity of the recursive version of the Euclid’s algorithm?
  \end{itemize}
\subsection{Divide and Conquer}
\subsubsection{Binary Search}
\end{enumerate}
